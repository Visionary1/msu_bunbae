<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MapleStory Boss Reward Tracker</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(45deg, #FF6B6B, #FFE66D);
            padding: 30px;
            text-align: center;
            color: white;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .room-section {
            padding: 30px;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
        }

        .room-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .input-group label {
            font-weight: bold;
            color: #495057;
        }

        input[type="text"] {
            padding: 12px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5a6fd8;
            transform: translateY(-2px);
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
        }

        .room-info {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #2196f3;
        }

        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            border-radius: 20px;
            color: white;
            font-weight: bold;
            z-index: 1000;
        }

        .status-connected {
            background: #28a745;
        }

        .status-disconnected {
            background: #dc3545;
        }

        .main-content {
            padding: 30px;
        }

        .boss-selection {
            margin-bottom: 30px;
        }

        .boss-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .boss-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 15px;
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            transition: all 0.3s;
        }

        .boss-item:hover {
            background: #e9ecef;
        }

        .boss-item.selected {
            background: #e3f2fd;
            border-color: #2196f3;
        }

        .boss-checkbox {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .boss-name {
            font-weight: bold;
            color: #495057;
        }

        .boss-details {
            margin-top: 30px;
            display: none;
        }

        .boss-details.active {
            display: block;
        }

        .boss-section {
            background: white;
            border-radius: 12px;
            margin: 20px 0;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            border: 2px solid #dee2e6;
        }

        .boss-header {
            background: linear-gradient(45deg, #FF6B6B, #FFE66D);
            padding: 20px;
            color: white;
            margin-bottom: 0;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.3s;
        }

        .boss-header:hover {
            background: linear-gradient(45deg, #ff5252, #ffd54f);
        }

        .boss-header h3 {
            margin: 0;
            font-size: 1.3em;
        }

        .boss-toggle {
            font-size: 1.2em;
            transition: transform 0.3s;
        }

        .boss-content {
            transition: max-height 0.3s ease-out;
            overflow: hidden;
        }

        .boss-content.collapsed {
            max-height: 0;
        }

        .boss-content.expanded {
            max-height: none;
        }

        .party-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .party-member {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 2px solid #dee2e6;
        }

        .member-info {
            display: grid;
            grid-template-columns: 1fr 1fr 100px;
            gap: 15px;
            margin-bottom: 15px;
        }

        .reward-input {
            margin-top: 15px;
        }

        .reward-row {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr auto;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
        }

        .remove-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
        }

        .add-reward-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            margin-top: 10px;
        }

        .distribution-section {
            background: #e8f5e8;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }

        .total-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #28a745;
            text-align: center;
            margin-bottom: 20px;
        }

        .distribution-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        .distribution-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .total-rewards-panel {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 12px;
            margin: 20px 0;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .total-rewards-header {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            padding: 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.3s;
        }

        .total-rewards-header:hover {
            background: linear-gradient(45deg, #218838, #1ea67a);
        }

        .total-rewards-header h3 {
            margin: 0;
            font-size: 1.3em;
        }

        .total-rewards-content {
            padding: 20px;
            background: white;
        }

        .total-rewards-content.collapsed {
            display: none;
        }

        .total-summary {
            text-align: center;
            margin-bottom: 20px;
        }

        .total-value-display {
            font-size: 2em;
            font-weight: bold;
            color: #28a745;
            background: #e8f5e8;
            padding: 15px;
            border-radius: 8px;
        }

        .total-distribution-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .total-distribution-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #dee2e6;
        }

        .total-transfers {
            background: #e3f2fd;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #2196f3;
        }

        .boss-breakdown {
            font-size: 0.9em;
            color: #6c757d;
            margin-top: 10px;
        }

        .boss-breakdown-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }

        .hidden {
            display: none;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2em;
            }
            
            .room-controls {
                flex-direction: column;
            }
            
            .member-info {
                grid-template-columns: 1fr;
            }
            
            .reward-row {
                grid-template-columns: 1fr;
            }

            .total-distribution-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="connection-status" id="connectionStatus">
        <span id="statusText">Connecting...</span>
    </div>

    <div class="container">
        <div class="header">
            <h1>🍁 MapleStory Boss Reward Tracker</h1>
            <p>Fair distribution of boss rewards among party members</p>
        </div>

        <div class="room-section">
            <div id="createRoom" class="room-controls">
                <div class="input-group">
                    <label for="roomName">Room Name:</label>
                    <input type="text" id="roomName" placeholder="Enter room name">
                </div>
                <button class="btn btn-primary" onclick="createRoom()">Create Room</button>
            </div>

            <div id="joinRoom" class="room-controls hidden">
                <div class="input-group">
                    <label for="joinCode">Room Code:</label>
                    <input type="text" id="joinCode" placeholder="Enter room code">
                </div>
                <button class="btn btn-success" onclick="joinRoom()">Join Room</button>
            </div>

            <div id="roomInfo" class="room-info hidden">
                <h3>Room: <span id="currentRoomName"></span></h3>
                <p>Share this code: <strong id="currentRoomCode"></strong></p>
                <p>Direct link: <a href="#" id="roomLink">Copy Link</a></p>
            </div>
        </div>

        <div class="main-content">
            <div id="mainApp" class="hidden">
                <div class="boss-selection">
                    <h2>Select Weekly Bosses</h2>
                    <div class="boss-grid">
                        <div class="boss-item" onclick="toggleBoss('chaos-zakum')">
                            <input type="checkbox" class="boss-checkbox" id="chaos-zakum">
                            <span class="boss-name">Chaos Zakum</span>
                        </div>
                        <div class="boss-item" onclick="toggleBoss('hard-hilla')">
                            <input type="checkbox" class="boss-checkbox" id="hard-hilla">
                            <span class="boss-name">Hard Hilla</span>
                        </div>
                        <div class="boss-item" onclick="toggleBoss('chaos-pierre')">
                            <input type="checkbox" class="boss-checkbox" id="chaos-pierre">
                            <span class="boss-name">Chaos Pierre</span>
                        </div>
                        <div class="boss-item" onclick="toggleBoss('chaos-von-bon')">
                            <input type="checkbox" class="boss-checkbox" id="chaos-von-bon">
                            <span class="boss-name">Chaos Von Bon</span>
                        </div>
                        <div class="boss-item" onclick="toggleBoss('chaos-crimson-queen')">
                            <input type="checkbox" class="boss-checkbox" id="chaos-crimson-queen">
                            <span class="boss-name">Chaos Crimson Queen</span>
                        </div>
                        <div class="boss-item" onclick="toggleBoss('chaos-vellum')">
                            <input type="checkbox" class="boss-checkbox" id="chaos-vellum">
                            <span class="boss-name">Chaos Vellum</span>
                        </div>
                        <div class="boss-item" onclick="toggleBoss('hard-magnus')">
                            <input type="checkbox" class="boss-checkbox" id="hard-magnus">
                            <span class="boss-name">Hard Magnus</span>
                        </div>
                        <div class="boss-item" onclick="toggleBoss('chaos-pink-bean')">
                            <input type="checkbox" class="boss-checkbox" id="chaos-pink-bean">
                            <span class="boss-name">Chaos Pink Bean</span>
                        </div>
                        <div class="boss-item" onclick="toggleBoss('easy-cygnus')">
                            <input type="checkbox" class="boss-checkbox" id="easy-cygnus">
                            <span class="boss-name">Easy Cygnus</span>
                        </div>
                        <div class="boss-item" onclick="toggleBoss('normal-cygnus')">
                            <input type="checkbox" class="boss-checkbox" id="normal-cygnus">
                            <span class="boss-name">Normal Cygnus</span>
                        </div>
                        <div class="boss-item" onclick="toggleBoss('chaos-papulatus')">
                            <input type="checkbox" class="boss-checkbox" id="chaos-papulatus">
                            <span class="boss-name">Chaos Papulatus</span>
                        </div>
                        <div class="boss-item" onclick="toggleBoss('normal-lotus')">
                            <input type="checkbox" class="boss-checkbox" id="normal-lotus">
                            <span class="boss-name">Normal Lotus</span>
                        </div>
                        <div class="boss-item" onclick="toggleBoss('normal-damien')">
                            <input type="checkbox" class="boss-checkbox" id="normal-damien">
                            <span class="boss-name">Normal Damien</span>
                        </div>
                    </div>
                </div>

                <!-- Total Rewards Panel -->
                <div id="totalRewardsPanel" class="total-rewards-panel hidden">
                    <div class="total-rewards-header" onclick="toggleTotalPanel()">
                        <h3>📊 Total Rewards Summary</h3>
                        <span id="totalPanelToggle">▼</span>
                    </div>
                    <div id="totalRewardsContent" class="total-rewards-content">
                        <div class="total-summary">
                            <div class="total-value-display" id="grandTotalValue">Grand Total: 0 NESO</div>
                        </div>
                        <div class="total-distribution-grid" id="totalDistributionGrid"></div>
                        <div class="total-transfers" id="totalTransfers"></div>
                    </div>
                </div>

                <div id="bossDetails" class="boss-details">
                    <!-- Boss details will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>

        let currentRoom = null;
                let selectedBosses = [];
                let partyMembers = [];
                let bossData = {};
                let socket = null;
                let saveTimeouts = {}; // For debouncing saves
                let dataLoadingComplete = false; // Track if initial data loading is complete
                let suppressSocketUpdates = false; // NEW: Prevent socket update loops
        
                // Debounced save function to prevent focus loss
                function debouncedSave(bossId, delay = 1000) {
                    // Clear existing timeout for this boss
                    console.log(`🕐 Debounced save called for boss: ${bossId}, delay: ${delay}ms`);

                    if (saveTimeouts[bossId]) {
                        console.log(`⏰ Clearing existing timeout for boss: ${bossId}`);
                        clearTimeout(saveTimeouts[bossId]);
                    }
                    
                    // Set new timeout
                    saveTimeouts[bossId] = setTimeout(() => {
                        console.log(`🚀 Executing delayed save for boss: ${bossId}`);
                        saveBossData(bossId);
                    }, delay);
                }
        
                // Initialize Socket.IO connection
                function initializeSocket() {
                    socket = io();
                    
                    socket.on('connect', () => {
                        updateConnectionStatus('connected');
                        if (currentRoom) {
                            socket.emit('joinRoom', currentRoom.code);
                        }
                    });
                    
                    socket.on('disconnect', () => {
                        updateConnectionStatus('disconnected');
                    });
                    
                    socket.on('bossDataUpdated', (data) => {
                        // FIXED: Only update if we're not suppressing updates and loading is complete
                        if (suppressSocketUpdates || !dataLoadingComplete) {
                            console.log('Suppressing socket update for:', data.bossId);
                            return;
                        }
        
                        // Only update if the data is actually different
                        if (!bossData[data.bossId] || JSON.stringify(bossData[data.bossId].data) !== JSON.stringify(data.data)) {
                            console.log('Applying socket update for:', data.bossId);
                            
                            bossData[data.bossId] = {
                                name: data.bossName,
                                data: data.data,
                                active: true
                            };
                            
                            if (selectedBosses.includes(data.bossId)) {
                                // Suppress our own updates while restoring
                                suppressSocketUpdates = true;
                                setTimeout(() => {
                                    restoreBossData(data.bossId);
                                    updateDistribution(data.bossId);
                                    updateTotalRewardsPanel();
                                    suppressSocketUpdates = false;
                                }, 100);
                            }
                        }
                    });
        
                    // NEW: Handle save errors
                    socket.on('saveError', (error) => {
                        console.error('Save error:', error);
                        alert('Failed to save data: ' + error.message);
                    });
                }
        
                function updateConnectionStatus(status) {
                    const statusElement = document.getElementById('connectionStatus');
                    const statusText = document.getElementById('statusText');
                    
                    if (status === 'connected') {
                        statusElement.className = 'connection-status status-connected';
                        statusText.textContent = '● Connected';
                    } else {
                        statusElement.className = 'connection-status status-disconnected';
                        statusText.textContent = '● Disconnected';
                    }
                }

// Room management
async function createRoom() {
            const roomName = document.getElementById('roomName').value.trim();
            if (!roomName) {
                alert('Please enter a room name');
                return;
            }

            try {
                const response = await fetch('/api/rooms', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ name: roomName })
                });

                if (response.ok) {
                    currentRoom = await response.json();
                    showRoom();
                    socket.emit('joinRoom', currentRoom.code);
                    dataLoadingComplete = true; // New room, no data to load
                } else {
                    alert('Failed to create room');
                }
            } catch (error) {
                console.error('Error creating room:', error);
                alert('Failed to create room');
            }
        }

        async function joinRoom() {
            const roomCode = document.getElementById('joinCode').value.trim().toUpperCase();
            if (!roomCode) {
                alert('Please enter a room code');
                return;
            }

            try {
                const response = await fetch(`/api/rooms/${roomCode}`);
                
                if (response.ok) {
                    currentRoom = await response.json();
                    showRoom();
                    socket.emit('joinRoom', currentRoom.code);
                    await loadBossData();
                } else {
                    alert('Room not found');
                }
            } catch (error) {
                console.error('Error joining room:', error);
                alert('Failed to join room');
            }
        }

        async function loadBossData() {
            console.log(`🔍 Loading boss data for room: ${currentRoom.code}`);
            
            // Suppress socket updates during initial loading
            suppressSocketUpdates = true;
            console.log(`🚫 Socket updates suppressed during loading`);
            
            try {
                console.log(`📡 Fetching data from: /api/rooms/${currentRoom.code}/boss-data`);
                const response = await fetch(`/api/rooms/${currentRoom.code}/boss-data`);
                
                console.log(`📋 Response status: ${response.status} ${response.statusText}`);
                
                if (response.ok) {
                    const serverBossData = await response.json();
                    console.log(`📦 Raw server boss data:`, serverBossData);
                    
                    // Check if we actually have any data
                    const hasData = Object.keys(serverBossData).length > 0;
                    console.log(`❓ Has server data: ${hasData}`);
                    
                    if (hasData) {
                        console.log(`📊 Processing ${Object.keys(serverBossData).length} bosses from server`);
                        
                        // First, update the bossData object
                        Object.keys(serverBossData).forEach(bossId => {
                            console.log(`🏆 Processing boss: ${bossId}`);
                            
                            bossData[bossId] = {
                                name: serverBossData[bossId].name,
                                data: serverBossData[bossId].data,
                                active: true
                            };
                            
                            const memberCount = bossData[bossId].data?.members?.length || 0;
                            console.log(`👥 Boss ${bossId} has ${memberCount} members`);
                            console.log(`📋 Boss ${bossId} data:`, bossData[bossId].data);
                            
                            // Update checkbox selection
                            const checkbox = document.getElementById(bossId);
                            if (checkbox) {
                                if (!checkbox.checked) {
                                    console.log(`☑️ Checking boss checkbox: ${bossId}`);
                                    checkbox.checked = true;
                                    const bossItem = checkbox.closest('.boss-item');
                                    bossItem.classList.add('selected');
                                    if (!selectedBosses.includes(bossId)) {
                                        selectedBosses.push(bossId);
                                    }
                                } else {
                                    console.log(`✅ Boss checkbox already checked: ${bossId}`);
                                }
                            } else {
                                console.error(`❌ Checkbox not found for boss: ${bossId}`);
                            }
                        });
                        
                        console.log(`📋 Selected bosses after processing:`, selectedBosses);
                        console.log(`📋 Complete bossData object:`, bossData);
                        
                        // Now update the boss details display
                        console.log(`🔄 Updating boss details display...`);
                        updateBossDetails();
                        
                        // After the DOM is updated, restore all the boss data
                        setTimeout(() => {
                            console.log(`🔄 Starting boss data restoration...`);
                            Object.keys(serverBossData).forEach((bossId, index) => {
                                console.log(`⏰ Scheduling restore for boss: ${bossId} (index: ${index})`);
                                setTimeout(() => {
                                    console.log(`🚀 Executing restore for boss: ${bossId}`);
                                    restoreBossData(bossId);
                                }, index * 150); // Stagger the restoration
                            });
                            
                            // Re-enable socket updates after restoration is complete
                            const restoreDelay = Object.keys(serverBossData).length * 150 + 300;
                            console.log(`⏰ Will re-enable socket updates in ${restoreDelay}ms`);
                            setTimeout(() => {
                                suppressSocketUpdates = false;
                                dataLoadingComplete = true;
                                console.log(`✅ Data loading complete, socket updates re-enabled`);
                            }, restoreDelay);
                        }, 400);
                    } else {
                        // No data to load
                        suppressSocketUpdates = false;
                        dataLoadingComplete = true;
                        console.log(`ℹ️ No server data found, loading complete`);
                    }
                } else {
                    console.error(`❌ Failed to fetch boss data: ${response.status} ${response.statusText}`);
                    suppressSocketUpdates = false;
                    dataLoadingComplete = true;
                }
            } catch (error) {
                console.error(`💥 Error loading boss data:`, error);
                suppressSocketUpdates = false;
                dataLoadingComplete = true;
            }
        }

        function showRoom() {
            document.getElementById('createRoom').classList.add('hidden');
            document.getElementById('joinRoom').classList.add('hidden');
            document.getElementById('roomInfo').classList.remove('hidden');
            document.getElementById('mainApp').classList.remove('hidden');

            document.getElementById('currentRoomName').textContent = currentRoom.name;
            document.getElementById('currentRoomCode').textContent = currentRoom.code;
            
            const roomLink = document.getElementById('roomLink');
            const url = `${window.location.origin}?room=${currentRoom.code}`;
            roomLink.href = url;
            roomLink.onclick = (e) => {
                e.preventDefault(); // Prevent navigation
                navigator.clipboard.writeText(url).then(() => {
                    alert('Link copied to clipboard!');
                }).catch(() => {
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = url;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    alert('Link copied to clipboard!');
                });
            };
        }

        // Boss selection
        function toggleBoss(bossId) {
            const checkbox = document.getElementById(bossId);
            checkbox.checked = !checkbox.checked;
            
            const bossItem = checkbox.closest('.boss-item');
            if (checkbox.checked) {
                bossItem.classList.add('selected');
                if (!selectedBosses.includes(bossId)) {
                    selectedBosses.push(bossId);
                }
            } else {
                bossItem.classList.remove('selected');
                selectedBosses = selectedBosses.filter(id => id !== bossId);
            }

            updateBossDetails();
        }

        function updateBossDetails() {
            const bossDetails = document.getElementById('bossDetails');
            
            if (selectedBosses.length === 0) {
                bossDetails.classList.remove('active');
                bossDetails.innerHTML = '';
                updateTotalRewardsPanel();
                return;
            }

            bossDetails.classList.add('active');
            
            selectedBosses.forEach(bossId => {
                const existingSection = document.getElementById(`boss-section-${bossId}`);
                if (!existingSection) {
                    const bossName = document.querySelector(`#${bossId}`).closest('.boss-item').querySelector('.boss-name').textContent;
                    const bossSection = createBossSection(bossId, bossName);
                    bossDetails.appendChild(bossSection);
                    
                    if (!bossData[bossId]) {
                        bossData[bossId] = {
                            name: bossName,
                            data: { members: [] },
                            active: true
                        };
                    }
                }
            });
            
            const allSections = bossDetails.querySelectorAll('.boss-section');
            allSections.forEach(section => {
                const sectionBossId = section.id.replace('boss-section-', '');
                if (!selectedBosses.includes(sectionBossId)) {
                    section.remove();
                    if (bossData[sectionBossId]) {
                        bossData[sectionBossId].active = false;
                    }
                }
            });

            updateTotalRewardsPanel();
        }

        function createBossSection(bossId, bossName) {
            const section = document.createElement('div');
            section.className = 'boss-section';
            section.id = `boss-section-${bossId}`;
            section.innerHTML = `
                <div class="boss-header" onclick="toggleBossPanel('${bossId}')">
                    <div>
                        <h3>${bossName}</h3>
                        <p style="margin: 5px 0 0 0; font-size: 0.9em; opacity: 0.9;">Date: ${new Date().toLocaleDateString()}</p>
                    </div>
                    <span class="boss-toggle" id="toggle-${bossId}">▼</span>
                </div>
                <div class="boss-content expanded" id="content-${bossId}">
                    <div class="party-section">
                        <h4>Party Members</h4>
                        <button class="btn btn-primary" onclick="addPartyMember('${bossId}')">Add Party Member</button>
                        <div id="party-${bossId}" class="party-members"></div>
                    </div>
                    <div class="distribution-section">
                        <div class="total-value" id="total-${bossId}">Total Value: 0 NESO</div>
                        <div class="distribution-grid" id="distribution-${bossId}"></div>
                    </div>
                </div>
            `;
            
            // If we have data for this boss, schedule restoration after DOM is ready
            if (bossData[bossId] && bossData[bossId].data && bossData[bossId].data.members) {
                setTimeout(() => {
                    console.log(`Scheduling restore for ${bossId}`);
                    restoreBossData(bossId);
                }, 50);
            }
            
            return section;
        }

        function toggleBossPanel(bossId) {
            const content = document.getElementById(`content-${bossId}`);
            const toggle = document.getElementById(`toggle-${bossId}`);
            
            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                content.classList.add('expanded');
                toggle.textContent = '▼';
            } else {
                content.classList.remove('expanded');
                content.classList.add('collapsed');
                toggle.textContent = '▶';
            }
        }

        function addPartyMember(bossId) {
            console.log(`Adding party member to boss: ${bossId}`);
            const partyContainer = document.getElementById(`party-${bossId}`);
            const memberId = `member-${bossId}-${Date.now()}`;
            
            const memberDiv = document.createElement('div');
            memberDiv.className = 'party-member';
            memberDiv.id = memberId;
            memberDiv.innerHTML = `
                <div class="member-info">
                    <div class="input-group">
                        <label>Character Name:</label>
                        <input type="text" placeholder="Enter character name" oninput="console.log('Character name changed:', this.value); debouncedSave('${bossId}'); updateDistributionOnly('${bossId}')">
                    </div>
                    <div class="input-group">
                        <label>Wallet Address:</label>
                        <input type="text" placeholder="0x..." oninput="console.log('Wallet changed:', this.value); debouncedSave('${bossId}'); updateDistributionOnly('${bossId}')">
                    </div>
                    <div class="input-group">
                        <label>Share %:</label>
                        <input type="number" value="0" min="0" max="100" oninput="console.log('Share % changed:', this.value); debouncedSave('${bossId}'); updateDistributionOnly('${bossId}')">
                    </div>
                </div>
                <div class="reward-input">
                    <h5>Rewards:</h5>
                    <div class="reward-rows" id="rewards-${memberId}"></div>
                    <button class="add-reward-btn" onclick="addReward('${memberId}')">Add Reward</button>
                </div>
                <button class="remove-btn" onclick="removeMember('${memberId}', '${bossId}')" style="margin-top: 10px;">Remove Member</button>
            `;
            
            partyContainer.appendChild(memberDiv);
            updateEvenDistribution(bossId);
            console.log(`Added member ${memberId} to boss ${bossId}, triggering save...`);
            debouncedSave(bossId, 500); // Quick save for new member
        }

        function addReward(memberId) {
            console.log(`Adding reward to member: ${memberId}`);
            const rewardsContainer = document.getElementById(`rewards-${memberId}`);
            const rewardId = `reward-${Date.now()}`;
            const bossId = memberId.split('-').slice(1, -1).join('-');
            
            const rewardDiv = document.createElement('div');
            rewardDiv.className = 'reward-row';
            rewardDiv.id = rewardId;
            rewardDiv.innerHTML = `
                <input type="text" placeholder="Item Name" oninput="console.log('Item name changed:', this.value); debouncedSave('${bossId}'); calculateRewardsOnly('${memberId}')">
                <input type="number" placeholder="Quantity" min="1" value="1" oninput="console.log('Quantity changed:', this.value); debouncedSave('${bossId}'); calculateRewardsOnly('${memberId}')">
                <input type="number" placeholder="NESO per item" min="0" oninput="console.log('NESO changed:', this.value); debouncedSave('${bossId}'); calculateRewardsOnly('${memberId}')">
                <button class="remove-btn" onclick="removeReward('${rewardId}', '${memberId}')">×</button>
            `;
            
            rewardsContainer.appendChild(rewardDiv);
            calculateRewardsOnly(memberId);
            console.log(`Added reward ${rewardId} to member ${memberId}, triggering save...`);
            debouncedSave(bossId, 500);
        }

        function removeReward(rewardId, memberId) {
            const bossId = memberId.split('-').slice(1, -1).join('-');
            console.log(`Removing reward ${rewardId} from member ${memberId}`);
            document.getElementById(rewardId).remove();
            calculateRewardsOnly(memberId);
            debouncedSave(bossId, 200);
        }

        function removeMember(memberId, bossId) {
            console.log(`Removing member ${memberId} from boss ${bossId}`);
            document.getElementById(memberId).remove();
            updateEvenDistribution(bossId);
            debouncedSave(bossId, 200);
        }

        function calculateRewardsOnly(memberId) {
            const bossId = memberId.split('-').slice(1, -1).join('-');
            updateDistributionOnly(bossId);
        }

        function updateEvenDistribution(bossId) {
            console.log(`Updating even distribution for boss: ${bossId}`);
            const partyContainer = document.getElementById(`party-${bossId}`);
            const members = partyContainer.querySelectorAll('.party-member');
            
            if (members.length === 0) return;
            
            const evenShare = Math.floor(100 / members.length);
            const remainder = 100 % members.length;
            
            members.forEach((member, index) => {
                const shareInput = member.querySelector('input[type="number"]');
                shareInput.value = evenShare + (index < remainder ? 1 : 0);
            });
            
            updateDistributionOnly(bossId);
        }

        // New function that only updates distribution without triggering re-renders
        function updateDistributionOnly(bossId) {
            const partyContainer = document.getElementById(`party-${bossId}`);
            const members = partyContainer.querySelectorAll('.party-member');
            
            let totalValue = 0;
            let totalPercentage = 0;
            const memberData = [];

            members.forEach(member => {
                const characterName = member.querySelector('input[type="text"]').value;
                const walletAddress = member.querySelectorAll('input[type="text"]')[1].value;
                const sharePercentage = parseInt(member.querySelector('input[type="number"]').value) || 0;
                
                const rewardRows = member.querySelectorAll('.reward-row');
                let memberRewardValue = 0;
                
                rewardRows.forEach(row => {
                    const inputs = row.querySelectorAll('input');
                    const quantity = parseInt(inputs[1].value) || 0;
                    const nesoPerItem = parseInt(inputs[2].value) || 0;
                    memberRewardValue += quantity * nesoPerItem;
                });
                
                totalValue += memberRewardValue;
                totalPercentage += sharePercentage;
                
                memberData.push({
                    name: characterName,
                    wallet: walletAddress,
                    percentage: sharePercentage,
                    earnedValue: memberRewardValue
                });
            });

            document.getElementById(`total-${bossId}`).textContent = `Total Value: ${totalValue} NESO`;
            
            const distributionContainer = document.getElementById(`distribution-${bossId}`);
            distributionContainer.innerHTML = '';
            
            const transfers = calculateTransfers(memberData, totalValue);
            
            memberData.forEach((member, index) => {
                const distributionAmount = Math.floor((totalValue * member.percentage) / 100);
                const deficit = distributionAmount - member.earnedValue;
                
                const memberDiv = document.createElement('div');
                memberDiv.className = 'distribution-item';
                memberDiv.innerHTML = `
                    <h5>${member.name || 'Unnamed'}</h5>
                    <p>Share: ${member.percentage}%</p>
                    <p>Should Receive: <strong>${distributionAmount} NESO</strong></p>
                    <p>Earned: ${member.earnedValue} NESO</p>
                    <p style="color: ${deficit > 0 ? 'green' : deficit < 0 ? 'red' : 'black'};">
                        ${deficit > 0 ? `Needs: +${deficit} NESO` : deficit < 0 ? `Owes: ${Math.abs(deficit)} NESO` : 'Balanced'}
                    </p>
                    <p style="font-size: 0.8em; word-break: break-all;">${member.wallet || 'No wallet'}</p>
                `;
                distributionContainer.appendChild(memberDiv);
            });

            if (transfers.length > 0) {
                const transferDiv = document.createElement('div');
                transferDiv.style.cssText = 'background: #e8f5e8; padding: 15px; border-radius: 8px; margin: 15px 0; grid-column: 1 / -1;';
                transferDiv.innerHTML = `
                    <h4>💸 Transfer Instructions:</h4>
                    ${transfers.map(transfer => 
                        `<p><strong>${transfer.from}</strong> → <strong>${transfer.to}</strong>: ${transfer.amount} NESO</p>`
                    ).join('')}
                `;
                distributionContainer.appendChild(transferDiv);
            }

            if (totalPercentage !== 100 && members.length > 0) {
                const warningDiv = document.createElement('div');
                warningDiv.style.cssText = 'background: #fff3cd; color: #856404; padding: 10px; border-radius: 5px; margin: 10px 0; text-align: center; grid-column: 1 / -1;';
                warningDiv.textContent = `Warning: Total percentage is ${totalPercentage}%, should be 100%`;
                distributionContainer.insertBefore(warningDiv, distributionContainer.firstChild);
            }

            updateTotalRewardsPanel();
        }

        function calculateTransfers(memberData, totalValue) {
            const transfers = [];
            const creditors = [];
            const debtors = [];

            memberData.forEach(member => {
                const shouldReceive = Math.floor((totalValue * member.percentage) / 100);
                const deficit = shouldReceive - member.earnedValue;
                
                if (deficit > 0) {
                    creditors.push({ name: member.name, amount: deficit });
                } else if (deficit < 0) {
                    debtors.push({ name: member.name, amount: Math.abs(deficit) });
                }
            });

            let creditorIndex = 0;
            let debtorIndex = 0;

            while (creditorIndex < creditors.length && debtorIndex < debtors.length) {
                const creditor = creditors[creditorIndex];
                const debtor = debtors[debtorIndex];
                
                const transferAmount = Math.min(creditor.amount, debtor.amount);
                
                if (transferAmount > 0) {
                    transfers.push({
                        from: debtor.name || 'Unnamed',
                        to: creditor.name || 'Unnamed',
                        amount: transferAmount
                    });
                }
                
                creditor.amount -= transferAmount;
                debtor.amount -= transferAmount;
                
                if (creditor.amount === 0) creditorIndex++;
                if (debtor.amount === 0) debtorIndex++;
            }

            return transfers;
        }

    // Data persistence and real-time sync
    async function saveBossData(bossId, suppressBroadcast = false) {
            console.log(`💾 saveBossData called for boss: ${bossId}, suppressBroadcast: ${suppressBroadcast}`);
            
            const partyContainer = document.getElementById(`party-${bossId}`);
            if (!partyContainer) {
                console.error(`❌ Party container not found for boss: ${bossId}`);
                return;
            }
            
            if (!currentRoom) {
                console.error(`❌ No current room set`);
                return;
            }
            
            const members = partyContainer.querySelectorAll('.party-member');
            console.log(`👥 Found ${members.length} party members for boss: ${bossId}`);
            
            const memberData = [];

            members.forEach((member, memberIndex) => {
                const inputs = member.querySelectorAll('input');
                console.log(`📝 Processing member ${memberIndex}, found ${inputs.length} inputs`);
                
                const characterName = inputs[0]?.value || '';
                const walletAddress = inputs[1]?.value || '';
                const sharePercentage = inputs[2]?.value || '0';
                
                console.log(`Member ${memberIndex}: name="${characterName}", wallet="${walletAddress}", share="${sharePercentage}"`);
                
                const rewardRows = member.querySelectorAll('.reward-row');
                console.log(`🎁 Found ${rewardRows.length} reward rows for member ${memberIndex}`);
                
                const rewards = [];
                
                rewardRows.forEach((row, rewardIndex) => {
                    const rewardInputs = row.querySelectorAll('input');
                    const reward = {
                        itemName: rewardInputs[0]?.value || '',
                        quantity: rewardInputs[1]?.value || '1',
                        nesoPerItem: rewardInputs[2]?.value || '0'
                    };
                    console.log(`Reward ${rewardIndex}:`, reward);
                    rewards.push(reward);
                });
                
                const memberInfo = {
                    id: member.id,
                    characterName,
                    walletAddress,
                    sharePercentage,
                    rewards
                };
                
                console.log(`📊 Complete member ${memberIndex} data:`, memberInfo);
                memberData.push(memberInfo);
            });

            const bossName = document.querySelector(`#${bossId}`).closest('.boss-item').querySelector('.boss-name').textContent;
            console.log(`🏆 Boss name: ${bossName}`);
            
            if (!bossData[bossId]) {
                bossData[bossId] = {};
            }
            bossData[bossId].data = { members: memberData };
            bossData[bossId].active = true;

            console.log(`📦 Final boss data for ${bossId}:`, {
                memberCount: memberData.length,
                bossName: bossName,
                data: bossData[bossId].data
            });

            // Only send to server if not suppressing broadcast
            if (!suppressBroadcast && socket && socket.connected) {
                console.log(`🌐 Sending data to server via socket for boss: ${bossId}`);
                console.log(`📡 Socket data being sent:`, {
                    roomCode: currentRoom.code,
                    bossId,
                    bossName,
                    bossData: { members: memberData }
                });
                
                socket.emit('updateBossData', {
                    roomCode: currentRoom.code,
                    bossId,
                    bossName,
                    bossData: { members: memberData }
                });
                console.log(`✅ Socket emit completed for boss: ${bossId}`);
            } else {
                console.log(`🚫 Skipping server save - suppressBroadcast: ${suppressBroadcast}, socket connected: ${socket?.connected}`);
            }
        }

        function restoreBossData(bossId) {
            console.log(`🔄 Attempting to restore data for boss: ${bossId}`);
            
            if (!bossData[bossId] || !bossData[bossId].data || !bossData[bossId].data.members) {
                console.log(`❌ No data to restore for boss: ${bossId}`, {
                    hasBossData: !!bossData[bossId],
                    hasData: !!bossData[bossId]?.data,
                    hasMembers: !!bossData[bossId]?.data?.members,
                    actualData: bossData[bossId]
                });
                return;
            }
            
            const partyContainer = document.getElementById(`party-${bossId}`);
            if (!partyContainer) {
                console.log(`❌ Party container not found for boss: ${bossId}, will retry...`);
                setTimeout(() => restoreBossData(bossId), 100);
                return;
            }

            const membersToRestore = bossData[bossId].data.members;
            console.log(`🔄 Restoring ${membersToRestore.length} members for boss: ${bossId}`, membersToRestore);

            // Clear existing members first
            partyContainer.innerHTML = '';

            membersToRestore.forEach((memberData, memberIndex) => {
                console.log(`👤 Restoring member ${memberIndex}:`, memberData);
                
                const memberId = memberData.id || `member-${bossId}-${Date.now()}-${memberIndex}`;
                
                const memberDiv = document.createElement('div');
                memberDiv.className = 'party-member';
                memberDiv.id = memberId;
                memberDiv.innerHTML = `
                    <div class="member-info">
                        <div class="input-group">
                            <label>Character Name:</label>
                            <input type="text" placeholder="Enter character name" value="${memberData.characterName || ''}" oninput="console.log('Restored field changed:', this.value); debouncedSave('${bossId}'); updateDistributionOnly('${bossId}')">
                        </div>
                        <div class="input-group">
                            <label>Wallet Address:</label>
                            <input type="text" placeholder="0x..." value="${memberData.walletAddress || ''}" oninput="console.log('Restored field changed:', this.value); debouncedSave('${bossId}'); updateDistributionOnly('${bossId}')">
                        </div>
                        <div class="input-group">
                            <label>Share %:</label>
                            <input type="number" value="${memberData.sharePercentage || 0}" min="0" max="100" oninput="console.log('Restored field changed:', this.value); debouncedSave('${bossId}'); updateDistributionOnly('${bossId}')">
                        </div>
                    </div>
                    <div class="reward-input">
                        <h5>Rewards:</h5>
                        <div class="reward-rows" id="rewards-${memberId}"></div>
                        <button class="add-reward-btn" onclick="addReward('${memberId}')">Add Reward</button>
                    </div>
                    <button class="remove-btn" onclick="removeMember('${memberId}', '${bossId}')" style="margin-top: 10px;">Remove Member</button>
                `;
                
                partyContainer.appendChild(memberDiv);
                console.log(`✅ Added member div for ${memberId}`);
                
                // Restore rewards for this member
                if (memberData.rewards && memberData.rewards.length > 0) {
                    console.log(`🎁 Restoring ${memberData.rewards.length} rewards for member ${memberIndex}`);
                    const rewardsContainer = document.getElementById(`rewards-${memberId}`);
                    
                    memberData.rewards.forEach((reward, rewardIndex) => {
                        console.log(`🎁 Restoring reward ${rewardIndex}:`, reward);
                        const rewardId = `reward-${Date.now()}-${memberIndex}-${rewardIndex}`;
                        const rewardDiv = document.createElement('div');
                        rewardDiv.className = 'reward-row';
                        rewardDiv.id = rewardId;
                        rewardDiv.innerHTML = `
                            <input type="text" placeholder="Item Name" value="${reward.itemName || ''}" oninput="console.log('Restored reward changed:', this.value); debouncedSave('${bossId}'); calculateRewardsOnly('${memberId}')">
                            <input type="number" placeholder="Quantity" min="1" value="${reward.quantity || 1}" oninput="console.log('Restored reward changed:', this.value); debouncedSave('${bossId}'); calculateRewardsOnly('${memberId}')">
                            <input type="number" placeholder="NESO per item" min="0" value="${reward.nesoPerItem || 0}" oninput="console.log('Restored reward changed:', this.value); debouncedSave('${bossId}'); calculateRewardsOnly('${memberId}')">
                            <button class="remove-btn" onclick="removeReward('${rewardId}', '${memberId}')">×</button>
                        `;
                        rewardsContainer.appendChild(rewardDiv);
                    });
                } else {
                    console.log(`ℹ️ No rewards to restore for member ${memberIndex}`);
                }
            });
            
            // Update the distribution after restoring all data
            setTimeout(() => {
                console.log(`📊 Updating distribution for restored boss: ${bossId}`);
                updateDistribution(bossId);
            }, 50);
            
            console.log(`✅ Restoration complete for boss: ${bossId}`);
        }

        // Distribution calculation
        function updateDistribution(bossId) {
            const partyContainer = document.getElementById(`party-${bossId}`);
            const members = partyContainer.querySelectorAll('.party-member');
            
            let totalValue = 0;
            let totalPercentage = 0;
            const memberData = [];

            members.forEach(member => {
                const characterName = member.querySelector('input[type="text"]').value;
                const walletAddress = member.querySelectorAll('input[type="text"]')[1].value;
                const sharePercentage = parseInt(member.querySelector('input[type="number"]').value) || 0;
                
                const rewardRows = member.querySelectorAll('.reward-row');
                let memberRewardValue = 0;
                
                rewardRows.forEach(row => {
                    const inputs = row.querySelectorAll('input');
                    const quantity = parseInt(inputs[1].value) || 0;
                    const nesoPerItem = parseInt(inputs[2].value) || 0;
                    memberRewardValue += quantity * nesoPerItem;
                });
                
                totalValue += memberRewardValue;
                totalPercentage += sharePercentage;
                
                memberData.push({
                    name: characterName,
                    wallet: walletAddress,
                    percentage: sharePercentage,
                    earnedValue: memberRewardValue
                });
            });

            document.getElementById(`total-${bossId}`).textContent = `Total Value: ${totalValue} NESO`;
            
            const distributionContainer = document.getElementById(`distribution-${bossId}`);
            distributionContainer.innerHTML = '';
            
            const transfers = calculateTransfers(memberData, totalValue);
            
            memberData.forEach((member, index) => {
                const distributionAmount = Math.floor((totalValue * member.percentage) / 100);
                const deficit = distributionAmount - member.earnedValue;
                
                const memberDiv = document.createElement('div');
                memberDiv.className = 'distribution-item';
                memberDiv.innerHTML = `
                    <h5>${member.name || 'Unnamed'}</h5>
                    <p>Share: ${member.percentage}%</p>
                    <p>Should Receive: <strong>${distributionAmount} NESO</strong></p>
                    <p>Earned: ${member.earnedValue} NESO</p>
                    <p style="color: ${deficit > 0 ? 'green' : deficit < 0 ? 'red' : 'black'};">
                        ${deficit > 0 ? `Needs: +${deficit} NESO` : deficit < 0 ? `Owes: ${Math.abs(deficit)} NESO` : 'Balanced'}
                    </p>
                    <p style="font-size: 0.8em; word-break: break-all;">${member.wallet || 'No wallet'}</p>
                `;
                distributionContainer.appendChild(memberDiv);
            });

            if (transfers.length > 0) {
                const transferDiv = document.createElement('div');
                transferDiv.style.cssText = 'background: #e8f5e8; padding: 15px; border-radius: 8px; margin: 15px 0; grid-column: 1 / -1;';
                transferDiv.innerHTML = `
                    <h4>💸 Transfer Instructions:</h4>
                    ${transfers.map(transfer => 
                        `<p><strong>${transfer.from}</strong> → <strong>${transfer.to}</strong>: ${transfer.amount} NESO</p>`
                    ).join('')}
                `;
                distributionContainer.appendChild(transferDiv);
            }

            if (totalPercentage !== 100 && members.length > 0) {
                const warningDiv = document.createElement('div');
                warningDiv.style.cssText = 'background: #fff3cd; color: #856404; padding: 10px; border-radius: 5px; margin: 10px 0; text-align: center; grid-column: 1 / -1;';
                warningDiv.textContent = `Warning: Total percentage is ${totalPercentage}%, should be 100%`;
                distributionContainer.insertBefore(warningDiv, distributionContainer.firstChild);
            }

            updateTotalRewardsPanel();
        }

        // Total rewards panel functions
        function updateTotalRewardsPanel() {
            const totalPanel = document.getElementById('totalRewardsPanel');
            
            if (selectedBosses.length < 2) {
                totalPanel.classList.add('hidden');
                return;
            }

            totalPanel.classList.remove('hidden');
            calculateTotalRewards();
        }

        function toggleTotalPanel() {
            const content = document.getElementById('totalRewardsContent');
            const toggle = document.getElementById('totalPanelToggle');
            
            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                toggle.textContent = '▼';
            } else {
                content.classList.add('collapsed');
                toggle.textContent = '▶';
            }
        }

        function calculateTotalRewards() {
            const allMembers = new Map();
            let grandTotal = 0;

            selectedBosses.forEach(bossId => {
                const partyContainer = document.getElementById(`party-${bossId}`);
                if (!partyContainer) return;

                const members = partyContainer.querySelectorAll('.party-member');
                let bossTotal = 0;

                members.forEach(member => {
                    const characterName = member.querySelector('input[type="text"]').value.trim();
                    const walletAddress = member.querySelectorAll('input[type="text"]')[1].value.trim();
                    const sharePercentage = parseInt(member.querySelector('input[type="number"]').value) || 0;
                    
                    const rewardRows = member.querySelectorAll('.reward-row');
                    let memberEarnedValue = 0;
                    
                    rewardRows.forEach(row => {
                        const inputs = row.querySelectorAll('input');
                        const quantity = parseInt(inputs[1].value) || 0;
                        const nesoPerItem = parseInt(inputs[2].value) || 0;
                        memberEarnedValue += quantity * nesoPerItem;
                    });

                    bossTotal += memberEarnedValue;

                    if (characterName) {
                        const memberKey = characterName.toLowerCase();
                        
                        if (!allMembers.has(memberKey)) {
                            allMembers.set(memberKey, {
                                displayName: characterName,
                                wallet: walletAddress,
                                bosses: new Map(),
                                totalEarned: 0,
                                totalShouldReceive: 0
                            });
                        }

                        const memberData = allMembers.get(memberKey);
                        
                        if (!memberData.wallet && walletAddress) {
                            memberData.wallet = walletAddress;
                        }

                        const shouldReceive = Math.floor((bossTotal * sharePercentage) / 100);
                        memberData.bosses.set(bossId, {
                            earned: memberEarnedValue,
                            shouldReceive: shouldReceive,
                            percentage: sharePercentage,
                            bossTotal: bossTotal
                        });
                    }
                });

                grandTotal += bossTotal;
            });

            allMembers.forEach((memberData, memberKey) => {
                memberData.totalEarned = 0;
                memberData.totalShouldReceive = 0;

                memberData.bosses.forEach((bossData, bossId) => {
                    const partyContainer = document.getElementById(`party-${bossId}`);
                    if (!partyContainer) return;

                    const members = partyContainer.querySelectorAll('.party-member');
                    let bossTotal = 0;

                    members.forEach(member => {
                        const rewardRows = member.querySelectorAll('.reward-row');
                        rewardRows.forEach(row => {
                            const inputs = row.querySelectorAll('input');
                            const quantity = parseInt(inputs[1].value) || 0;
                            const nesoPerItem = parseInt(inputs[2].value) || 0;
                            bossTotal += quantity * nesoPerItem;
                        });
                    });

                    const shouldReceive = Math.floor((bossTotal * bossData.percentage) / 100);
                    bossData.shouldReceive = shouldReceive;
                    bossData.bossTotal = bossTotal;

                    memberData.totalEarned += bossData.earned;
                    memberData.totalShouldReceive += shouldReceive;
                });
            });

            displayTotalRewards(allMembers, grandTotal);
        }

        function displayTotalRewards(allMembers, grandTotal) {
            document.getElementById('grandTotalValue').textContent = `Grand Total: ${grandTotal} NESO`;

            const distributionGrid = document.getElementById('totalDistributionGrid');
            distributionGrid.innerHTML = '';

            const transferData = [];

            allMembers.forEach((memberData, memberKey) => {
                const deficit = memberData.totalShouldReceive - memberData.totalEarned;
                
                const memberDiv = document.createElement('div');
                memberDiv.className = 'total-distribution-item';
                
                let bossBreakdown = '';
                memberData.bosses.forEach((bossData, bossId) => {
                    const bossName = document.querySelector(`#${bossId}`).closest('.boss-item').querySelector('.boss-name').textContent;
                    bossBreakdown += `
                        <div class="boss-breakdown-item">
                            <span>${bossName}:</span>
                            <span>Earned ${bossData.earned}, Should get ${bossData.shouldReceive} (${bossData.percentage}%)</span>
                        </div>
                    `;
                });

                memberDiv.innerHTML = `
                    <h5>${memberData.displayName}</h5>
                    <p><strong>Total Earned:</strong> ${memberData.totalEarned} NESO</p>
                    <p><strong>Total Should Receive:</strong> ${memberData.totalShouldReceive} NESO</p>
                    <p style="color: ${deficit > 0 ? 'green' : deficit < 0 ? 'red' : 'black'}; font-weight: bold;">
                        ${deficit > 0 ? `Needs: +${deficit} NESO` : deficit < 0 ? `Owes: ${Math.abs(deficit)} NESO` : 'Balanced ✓'}
                    </p>
                    <div class="boss-breakdown">
                        <strong>Boss Breakdown:</strong>
                        ${bossBreakdown}
                    </div>
                    <p style="font-size: 0.8em; word-break: break-all; color: #6c757d;">
                        ${memberData.wallet || 'No wallet address'}
                    </p>
                `;
                
                distributionGrid.appendChild(memberDiv);

                transferData.push({
                    name: memberData.displayName,
                    wallet: memberData.wallet,
                    deficit: deficit
                });
            });

            displayOptimizedTransfers(transferData);
        }

        function displayOptimizedTransfers(transferData) {
            const transfersContainer = document.getElementById('totalTransfers');
            
            const creditors = transferData.filter(member => member.deficit > 0);
            const debtors = transferData.filter(member => member.deficit < 0);

            if (creditors.length === 0 && debtors.length === 0) {
                transfersContainer.innerHTML = '<h4>💰 All members are balanced! No transfers needed.</h4>';
                return;
            }

            const transfers = [];
            let creditorIndex = 0;
            let debtorIndex = 0;

            const creditorsCopy = creditors.map(c => ({ ...c, amount: c.deficit }));
            const debtorsCopy = debtors.map(d => ({ ...d, amount: Math.abs(d.deficit) }));

            while (creditorIndex < creditorsCopy.length && debtorIndex < debtorsCopy.length) {
                const creditor = creditorsCopy[creditorIndex];
                const debtor = debtorsCopy[debtorIndex];
                
                const transferAmount = Math.min(creditor.amount, debtor.amount);
                
                if (transferAmount > 0) {
                    transfers.push({
                        from: debtor.name,
                        fromWallet: debtor.wallet,
                        to: creditor.name,
                        toWallet: creditor.wallet,
                        amount: transferAmount
                    });
                }
                
                creditor.amount -= transferAmount;
                debtor.amount -= transferAmount;
                
                if (creditor.amount === 0) creditorIndex++;
                if (debtor.amount === 0) debtorIndex++;
            }

            let transfersHTML = '<h4>💸 Optimized Transfer Instructions:</h4>';
            
            if (transfers.length === 0) {
                transfersHTML += '<p>No transfers needed - all members are balanced!</p>';
            } else {
                transfers.forEach(transfer => {
                    transfersHTML += `
                        <div style="background: white; padding: 12px; margin: 8px 0; border-radius: 6px; border-left: 4px solid #28a745;">
                            <strong>${transfer.from}</strong> → <strong>${transfer.to}</strong>: <span style="color: #28a745; font-weight: bold;">${transfer.amount} NESO</span><br>
                            <small style="color: #6c757d;">
                                From: ${transfer.fromWallet || 'No wallet'}<br>
                                To: ${transfer.toWallet || 'No wallet'}
                            </small>
                        </div>
                    `;
                });
            }

            transfersContainer.innerHTML = transfersHTML;
        }

        // Initialize everything
        window.addEventListener('load', () => {
            initializeSocket();
            
            document.getElementById('createRoom').classList.remove('hidden');
            document.getElementById('joinRoom').classList.remove('hidden');

            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('room')) {
                document.getElementById('joinCode').value = urlParams.get('room');
            }
        });
    </script>
</body>
</html>
